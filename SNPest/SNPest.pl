#!/usr/bin/perl -w use strict;
use Getopt::Long;
use List::Util qw(shuffle);
use POSIX qw(strftime);

my $i;
my $id;
my $pos;
my $ref;
my $depth;
my $readdata;
my $qualities;
my $mappingquals;
my $counter=0;
my $tabline="";
my $firstfield;
my $temp;
my @genotypes;
my @posteriors;
my @fields;
my $postprob;
my $genotype;
my $phred;
my $ALT;
my $INFO;
my $log10=log(10);
my $maxqual=50;
my $minprob=0.000001;
my $qual;
my $mycommand;
my $avmapq;

sub minimum{
    my $a=shift;
    my $b=shift;
    my $c=shift;
    if($a<=$b && $a<=$c){
	return $a;
    }
    elsif($b<=$a && $b<=$c){
	return $b;
    }
    else{
	return $c;
    }
}

#my $DATE = Time::Piece->new->strftime('%Y%m%d');
my $DATE = strftime "%Y%m%d", localtime;

# Program version
my $VERSION="SNPest ver. 1.0\n";

# We use maxdepth as the maximum read depth. If depth is greater, we randomly down sample the reads
# Default is 200X but this can be set by the parameter --maxdepth <int>
my $maxdepth=200;

# This is where the executables etc. are places. 
# The path can be changed by the parameter --execpath <string>
my $dfgpath=".";

# This is the ploidity of the genome.
# Default is diploid but this can be set by the parameter --ploidity <string>
my $ploidity="diploid";

# This is the specific model used (if any) - e.g. damaged aDNA
# Default is not to use but can be set by the parameter --model <string>
my $model="error";

# This tells us whether to use the reference genome.
# Default is to use (true), but this can be set by the parameter --noref
my $noref=0;

# This tells us how many lines of input to process at a time. 
# High value=faster processing but larger memory footprint
# Default is 5,000,000,000 but this can be set by the parameter --batchsize <int>
my $batchsize=5000000000;

# This is the quality score offset used. It is either Phred+64 (i.e., Illumina 1.3+ and 1.5+) or Phred+33 (Illumina 1.8+).
# The default is 33
my $qualbase=33; 

# The help text
# Use --h/--help/-h/-H for help
my $HELPTEXT="This is SNPest, a program for calculating genotypes based on sequencing reads with quality scores. It reads input in generated by 'samtools mpileup' from STDIN and outputs genotype data in VCF format on STDOUT. You can use the following parameters:\n--maxdepth <MAX>:\tSet the maximum depth used in the calculations to MAX. If more than MAX reads cover a position, we randomly down-sample the reads to MAX. Default is 200.\n--execpath <PATH>:\tSet the PATH to where the programs and models are located. Default is '.' and implicitly the sub directory ./dfgspec/ (see the manpage for details).\n--ploidity <VALUE>:\tSet to either diploid (default) or haploid\n--model <VALUE>:\tSpecify model (ancient) or nothing (default).\n--noref:\tPer default, the reference genome is used as prior information. Use this parameter to only use the observed data.\n--batchsize <SIZE>:\tSet the number of lines to process at a time. By default, the value is ".$batchsize.". Larger values makes the program run faster but also demands more memory.\n--version:\tPrint the version number and exit.\n--h/--help/-h/-help:\tPrint this nifty little text and exit.\n ";

# The reference file name (if supplied by the user)
my $REFERENCEFILE="";

GetOptions( "maxdepth:i" => \$maxdepth,
	    "execpath:s" => \$dfgpath,
	    "ploidity:s" => \$ploidity,
	    "model:s" => \$model,
	    "batchsize:i" => \$batchsize,
	    "qualbase:i" => \$qualbase,
	    "version" => \$version,
	    "noref" => \$noref,
	    "help"  => \$help,
	    "reference:s" => \$REFERENCEFILE)
or die("Unrecognized arguments.\n");

if($version){
    print $VERSION;
    exit;
}
if($help){
    print $VERSION;
    print $HELPTEXT;
    exit;
}

if($REFERENCEFILE ne ""){
    $REFERENCEFILE="##reference=file:".$REFERENCEFILE."\n";
}

# The VCF header. Update information as appropriate.
# We only use a subset of the fields, but this might be extended in time.
my $vcfheader="##fileformat=VCFv4.2\n##fileDate=".$DATE."\n##source=".$VERSION.$REFERENCEFILE."##model=".$model."\n##maxDepth=".$maxdepth."\n##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">\n##INFO=<ID=PP,Number=1,Type=Float,Description=\"Posterior probability\">\n##INFO=<ID=AVMQ,Number=1,Type=Integer,Description=\"Average mapping quality\">\n##INFO=<ID=DEL,Number=1,Type=Integer,Description=\"Comma separated list of number of reads supporting deletion(s)\">\n##INFO=<ID=FRACDEL,Number=1,Type=Float,Description=\"Comma separated list of fraction of reads supporting deletion(s)\">\n##INFO=<ID=INS,Number=1,Type=Integer,Description=\"Comma separated list of number of reads supporting insertion(s)\">\n##INFO=<ID=FRACINS,Number=1,Type=Float,Description=\"Comma separated list of fraction of reads supporting insertion(s)\">\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\n";

# Set the genotype number: Diploid=10 and haploid=4
my $genotypenumber=10;
if($ploidity eq "haploid"){
    $genotypenumber=4;
}

#We create a file for the input needed by dfgeval
#Since we are treating the input in batches, we are reusing the same file
my $randomid=int(rand(1000000));
my $tabfilename=$dfgpath."/".$randomid.".tab";
open TABFILE, ">", $tabfilename or die $!;

#Generate the header
my $header="NAME:\tC";
for($i=1;$i<=$maxdepth;$i++){
    $header=$header."\tO".$i;
}

print TABFILE $header."\n";

#The file name we will use for the genotype calculations
my $genotypefilename=$dfgpath."/".$randomid."_dfgEval.out";
#my $genotypefilename="/home/stinus/programs/SNPest/test_diploid_out.txt";

# Print the settings
print STDERR "The program settings are:\nMax depth: ".$maxdepth."\nPloidity: ".$ploidity." (".$genotypenumber." genotypes)\nModel specified: ".$model."\nUse reference: ".($noref?"no":"yes")."\nExecution path: ".$dfgpath."\nBatchsize: ".$batchsize."\nTabfile: ".$tabfilename."\nQuality base: ".$qualbase."\nOutput from dfgEval_SNPest is put here: ".$genotypefilename."\n";

print STDOUT $vcfheader;

my $hit;
my @splitreads;
my $insertion;
my $MAXINSDEPTH;
my $INSERTIONS;
my $DELETIONS;

while(<STDIN>){
    $counter++;
    chomp $_;
    # Read and parse the input
    ($id,$pos,$ref,$depth,$readdata,$qualities,$mappingquals)=split(/[ \t]+/,$_);
    $ref=uc($ref);
    
    # Clean up the read data
    #Remove ^ and the following char (do this first)
    #Remove $
    #Remove -N and the following N chars
    #Since we only care about the forward strand, we can change all . and , to ref
    #NOTE: upper cas/lower case appears to only indicate strand - the letter is always on the forward strand.
    #Thus, 'a' means a mismatch on the reverse strand resulting in 'A' on the forward strand.

    # Insertions: Generate additional lines, flag positions as insertions, use reference N, use mapQ
    # Deletions: Remove * and corresponding qualities, flag position as potential deletion
    $readdata =~ s/\^.//g;
    $readdata =~ s/\$//g;
    $readdata =~ s/[.,]/$ref/g;
    if($readdata =~ m/-[0-9]/){
	@splitreads=split(/-/,$readdata);
	for($i=0;$i<@splitreads;$i++){
	    if($splitreads[$i] =~ s/^([0-9]+)//){
		$hit=$1;
		$splitreads[$i] =~ s/^[a-zA-Z]{$hit}//;
	    }
	}
	$readdata=join('',@splitreads);
    }
    $INSERTIONS=0;
    $MAXINSDEPTH=0;
    my @INSLIST;
    if($readdata =~ m/\+[0-9]/){
	@splitreads=split(/\+/,$readdata);
	for($i=0;$i<@splitreads;$i++){
	    if($splitreads[$i] =~ s/^([0-9]+)//){
		$MAXINSDEPTH++;
		$hit=$1;
		$insertion=uc(substr($splitreads[$i] , 0 , $hit));
		$INSERTIONS=($INSERTIONS < $hit) ? $hit : $INSERTIONS;
		push(@INSLIST,$insertion);
		$splitreads[$i] =~ s/^[a-zA-Z]{$hit}//;
	    }
	}
	$readdata=join('',@splitreads);
    }
    #$readdata =~ tr/[acgtn]/[TGCAN]/;
    $readdata = uc($readdata);

    if(length($readdata) != length($qualities)){
	print STDERR $_."\nnot equal lengths:\n".$readdata."\n".$qualities."\n";
	exit;
    }
    my @nucs=split(//,$readdata);
    my @quals=split(//,$qualities);
    my @mapqs=split(//,$mappingquals);

    $DELETIONS=0;
    for($i=0;$i<@nucs;$i++){
	if($nucs[$i] eq '*'){
	    $DELETIONS++;
	    $depth--;
	    $nucs[$i]=' ';
	    $quals[$i]=' ';
	    $mapqs[$i]=' ';
	}
    }

    if($DELETIONS>0){
	@nucs = grep {$_ ne " "} @nucs;
	@mapqs = grep {$_ ne " "} @mapqs;
	@quals = grep {$_ ne " "} @quals;
    }

    if($depth>0){
	#If the depth is less than or equal to $maxdepth, use all the data
	#Otherwise, randomly sample $maxdepth reads with corresponding quality
	#We do this by randomly shuffling the indices from 0 to $#nucs
	#and using the first $maxdepth indices
	my @indices=(0..$#nucs);
	if($depth > $maxdepth){
	    #Shuffle and only use the first $maxdepth indices
	    @indices=shuffle(@indices);
	    $#indices=$maxdepth-1;
	}
    
	# Use the minimum of mapping quality and nucleotide quality
	# Truncate qualities at $maxqual
	$avmapq=0;
	$tabline="";
	foreach $i (@indices){
	    $avmapq=$avmapq+ord($mapqs[$i])-$qualbase;
	    $qual=minimum(ord($quals[$i])-$qualbase,ord($mapqs[$i])-$qualbase,$maxqual);
	    $qual=($qual>0)?$qual:1;
	    $tabline=$tabline."\t".$nucs[$i].$qual;
	}
	$avmapq=int($avmapq/($#indices+1)+0.5);
	#Now, create a line in the tabfile for dfgeval
	#Generate an ID containing all the info we need (id, pos, ref, average mapping quality and depth)
	$firstfield=$id."_".$pos."_".$ref."_".$avmapq."_".$depth;
	if($DELETIONS>0){
	    $firstfield=$firstfield.";DEL=".$DELETIONS.";FRACDEL=".($DELETIONS/($DELETIONS+$depth));
	}
	if($noref){
	    #Just use N
	    $ref="N";
	}
	$tabline=$firstfield."\t".$ref.$tabline;
    }
    else{
	# In case whole position is deleted: Mark and call with N
	$tabline=$id."_".$pos."_".$ref."_".$qualbase."_1;DEL=".$DELETIONS.";FRACDEL=1.0\tN\tN".$qualbase;
    }
    print TABFILE $tabline."\n";
    
    for($i=0;$i<$INSERTIONS;$i++){
	$firstfield=$id."_".$pos."_N_".$avmapq;
	$depth=0;
	$tabline="";
	for(my $j=0;$j<$MAXINSDEPTH && $depth<$maxdepth;$j++){
            $qual=($avmapq>$maxqual)?$maxqual:$avmapq;
            if(length($INSLIST[$j])>$i){
                $depth++;
                $tabline=$tabline."\t".substr($INSLIST[$j],$i,1).$qual;
            }
	}
	$tabline=$firstfield."_".(($depth==$maxdepth)?$MAXINSDEPTH:$depth).";INS=".(($depth==$maxdepth)?$MAXINSDEPTH:$depth)."\tN".$tabline;
	print TABFILE $tabline."\n";
    }

    # Test if we have either read $batchsize lines and should process them before continuing, 
    # or if we have read the last line of the file and should process the last (potentially smaller) set of input
    if($counter==$batchsize || eof){
	close(TABFILE);
	# Call dfgeval with input file
	$mycommand=$dfgpath."/dfgEval_SNPest --ppVars=G --ppSumOther --ppFile=- --dfgSpecPrefix=".$dfgpath."/dfgspec/ --maxDepth=".$maxdepth." --ploidity=".$ploidity." --model=".$model." ".$tabfilename." > ".$genotypefilename;
	print STDERR $mycommand."\n";
	system $mycommand;

	# Parse the generated output from dfgeval and print to STDOUT
	open GENOFILE, "<", $genotypefilename or die $!;
	
	#Read the first line containing NAME ranVar [genotypes]
	$temp=<GENOFILE>;
	chomp $temp;
	@genotypes=(split(/\t/,$temp))[2 .. $genotypenumber+1];

	#Parse each line corresponding to a position in the genome
	while(<GENOFILE>){
	    chomp $_;
	    @posteriors=(split(/\t/,$_));
	    #The first field contains identifier, position, reference nucleotide, average maping quality and read depth (cf. how we generate the tab-file above)
	    @fields=split(/_/,$posteriors[0]);

	    $id=join('_',@fields[0..$#fields-4]);
	    $pos=$fields[$#fields-3];
	    $ref=$fields[$#fields-2];
	    $avmapq=$fields[$#fields-1];
	    $depth=$fields[$#fields];
	    #Positions 2 and on contain posterior probabilities corresponding to the genotypes
	    @posteriors=@posteriors[2 .. $genotypenumber+1];
	    $postprob=2.0;
	    $genotype="NN";
	    for($i=0;$i<$genotypenumber;$i++){
		if($posteriors[$i]<$postprob){
		    #We found a better candidate
		    $postprob=$posteriors[$i];
		    $genotype=$genotypes[$i];
		}
	    }
	    $postprob=($postprob<$minprob)?$minprob:$postprob;
	    #Write vcf output. We set the ID (e.g. dbSNP) to '.', and the same for filter. 
	    #This might be changed in the future (e.g. filter predictions based on posterior probability, depth etc.)
	    #For ALT, we use '.' to indicate a reference hit so e.g. "." means a homozygous position identical to the reference,
	    #'.A' would mean a heterozygous position with one allelle being the reference and the other in this case an A, and
	    #'CG' would mean a heterozygous position with both allelles different from the reference.
	    if(substr($genotype,0,1) eq substr($genotype,1,1)){
		#If homozygous, only print nucleotide once
		$genotype=substr($genotype,0,1);
	    }
	    else{
		#It's heterozygous. Put a comma between the two nucleotides
		$genotype=substr($genotype,0,1).",".substr($genotype,1,1);
	    }
	    #Finally, replace any reference nucleotides with .
	    $genotype =~ s/$ref/./;
	    
	    #The phred quality is: -10log_10 prob(call in ALT is wrong)
	    #The value in $postprob is actually 1-posterior.
	    $phred=-10*(log($postprob)/$log10) + 1;
	    #Now, set $postprob to the actual posterior probability
	    $postprob=1-$postprob;
	    $INFO="DP=".$depth.";PP=".$postprob.";AVMQ=".$avmapq;
	    print STDOUT $id."\t".$pos."\t.\t".$ref."\t".$genotype."\t".int($phred)."\t.\t".$INFO."\n";
  	}

	close(GENOFILE);
	# Reset counter and input file
	$counter=0;
	
	open TABFILE, ">", $tabfilename or die $!;
	print TABFILE $header."\n";
    }
}
close(TABFILE);

unlink $genotypefilename;
unlink $tabfilename;

exit;
