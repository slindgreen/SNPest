#define BOOST_TEST_DYN_LINK

// bost test
#include <boost/test/unit_test.hpp>
#include <boost/test/floating_point_comparison.hpp>

// convenient definitions 
#include "phy/test/PhyTestDef.h"

// tested code (the defines allow access to private data)
#define private public
#define protected public
#include "phy/Factors.h"
#undef protected
#undef private 

// input/output not included by above
#include <boost/numeric/ublas/io.hpp>
#include <iostream>

// other stuff
#include <boost/foreach.hpp>

using namespace phy;
using boost::unit_test::test_suite;
using namespace std;

// helper functions
matrix_t mkAndFillSquareMatrixIncr(unsigned n)
{
  matrix_t m(n, n);
  for (unsigned i = 0; i < n; i++) 
    for (unsigned j = 0; j < n; j++) 
      m(i, j) = i * n + j;
  return m;
}


matrix_t mkAndFillSquareMatrixUnif(unsigned n)
{
  matrix_t m(n, n);
  for (unsigned i = 0; i < n; i++) 
    for (unsigned j = 0; j < n; j++) 
      m(i, j) = 1.0 / (n * n);
  return m;
}


BOOST_AUTO_TEST_CASE(GlobalNormFactor_mkFactor_1) 
{
  GlobalNormFactor fac(mkAndFillSquareMatrixIncr(4));
  matrix_t n = fac.mkFactor();

  for (unsigned i = 0; i < 4; i++) 
    for (unsigned j = 0; j < 4; j++) 
      BOOST_CHECK(n(i, j) == i * 4 + j);
}

BOOST_AUTO_TEST_CASE(GlobalNormFactor_optimizeParameters_1) 
{
  matrix_t m = mkAndFillSquareMatrixIncr(4);
  matrix_t pseudo = mkAndFillSquareMatrixIncr(4);
  GlobalNormFactor fac(m , pseudo); // m will be overridden by optimization below
  fac.submitCounts(m);
  fac.optimizeParameters();
  matrix_t n = fac.mkFactor();

  BOOST_CHECK_CLOSE(sumMatrix(n), 1.0, EPS);
  BOOST_CHECK_CLOSE(n(0, 0), 0.0, EPS);
  BOOST_CHECK_CLOSE(n(3, 3), 0.125, EPS);
}


BOOST_AUTO_TEST_CASE(GlobalNormFactor_constructor_1) 
{
  matrix_t m = mkAndFillSquareMatrixIncr(4);
  matrix_t pseudo = mkAndFillSquareMatrixIncr(4);
  GlobalNormFactor fac(m, pseudo);

  for (unsigned i = 0; i < 4; i++) 
    for (unsigned j = 0; j < 4; j++) 
      BOOST_CHECK(fac.m_(i, j) == i * 4 + j);
}


BOOST_AUTO_TEST_CASE(GlobalNormFactor_submitCounts_1) 
{
  matrix_t m = mkAndFillSquareMatrixIncr(4);
  GlobalNormFactor fac(m);

  // uniform count matrix
  matrix_t c(4, 4);
  for (unsigned i = 0; i < 4; i++) 
    for (unsigned j = 0; j < 4; j++) 
      c(i, j) = 1;

  fac.submitCounts(c);
  fac.optimizeParameters();
  matrix_t par = fac.m_;

  for (unsigned i = 0; i < 4; i++) 
    for (unsigned j = 0; j < 4; j++) 
      BOOST_CHECK_CLOSE(par(i, j), 1.0/16, EPS);
}  


BOOST_AUTO_TEST_CASE(GlobalNormFactor_submitCounts_2) 
{
  matrix_t m = mkAndFillSquareMatrixIncr(4);
  matrix_t pseudo = mkAndFillSquareMatrixIncr(4);
  GlobalNormFactor fac(m, pseudo);

  // uniform count matrix
  matrix_t c(4, 4);
  reset(c);

  fac.submitCounts(c);
  fac.optimizeParameters();

  for (unsigned i = 0; i < 4; i++) 
    for (unsigned j = 0; j < 4; j++) 
      BOOST_CHECK_CLOSE(fac.m_(i, j), pseudo(i, j) / sumMatrix(pseudo), EPS);
}  


BOOST_AUTO_TEST_CASE(RowNormFactor_general_1) 
{
  matrix_t m(4, 4);
  reset(m);
  RowNormFactor fac(m);

  matrix_t c = mkAndFillSquareMatrixIncr(4);
  fac.submitCounts(c);
  fac.optimizeParameters();

  matrix_t n = fac.mkFactor();
    BOOST_CHECK(n(0, 0) == 0.0);
  for (unsigned i = 0; i < 4; i++)
    BOOST_CHECK_CLOSE(sum( row(n,i) ), 1.0, EPS);
}


BOOST_AUTO_TEST_CASE(ColumnNormFactor_general_1) 
{
  matrix_t m(4, 4);
  reset(m);
  ColumnNormFactor fac(m);

  matrix_t c = mkAndFillSquareMatrixIncr(4);
  fac.submitCounts(c);
  fac.optimizeParameters();

  matrix_t n = fac.mkFactor();
    BOOST_CHECK(n(0, 0) == 0.0);
    BOOST_CHECK_CLOSE(n(3, 0), 0.5, EPS);

  for (unsigned i = 0; i < 4; i++)
    BOOST_CHECK_CLOSE(sum( column(n,i) ), 1.0, EPS);

  //  cout << n << endl;
}


BOOST_AUTO_TEST_CASE(CompositeFactorSet_mkFactor_1) 
{
  // define factor set
  matrix_t m0 = mkAndFillSquareMatrixIncr(4);
  matrix_t m1 = mkAndFillSquareMatrixUnif(4);

  AbsBasFacPtr_t fac1Ptr(new GlobalNormFactor(m0) );
  AbsBasFacPtr_t fac2Ptr(new GlobalNormFactor(m1) );

  // note that factor 0 and 2 are the same.
  std::vector<AbsBasFacPtr_t> factorPtrs;
  factorPtrs.push_back(fac1Ptr);
  factorPtrs.push_back(fac2Ptr);
  factorPtrs.push_back(fac1Ptr);

  CompositeFactorSet facSet(factorPtrs);

  // test mkFactor
  BOOST_CHECK(matrixEqual(facSet.mkFactor(0), m0) );
  BOOST_CHECK(matrixEqual(facSet.mkFactor(1), m1) );
  BOOST_CHECK(matrixEqual(facSet.mkFactor(2), m0) );

  BOOST_CHECK(matrixEqual(facSet.mkFactorVec()[0], m0) );
  BOOST_CHECK(matrixEqual(facSet.mkFactorVec()[1], m1) );
  BOOST_CHECK(matrixEqual(facSet.mkFactorVec()[2], m0) );

  // check submitCounts and optimizeParameters
  facSet.submitCounts(m1, 0);
  facSet.submitCounts(m1, 1);
  facSet.submitCounts(m1, 2);

  facSet.optimizeParameters();

  BOOST_CHECK(matrixEqual(facSet.mkFactor(0), m1) );
  BOOST_CHECK(matrixEqual(facSet.mkFactor(1), m1) );
  BOOST_CHECK(matrixEqual(facSet.mkFactor(2), m1) );

  // diff counts
  facSet.submitCounts(m1, 0);
  facSet.submitCounts(m1, 1);
  facSet.submitCounts(m0, 2);

  facSet.optimizeParameters();

  BOOST_CHECK(not matrixEqual(facSet.mkFactor(0), m1) );
  BOOST_CHECK(matrixEqual(facSet.mkFactor(1), m1) );
  BOOST_CHECK(not matrixEqual(facSet.mkFactor(2), m1) );

  BOOST_CHECK(matrixEqual( facSet.mkFactor(2), facSet.mkFactor(0) ) );

  // output factor matrices
  // BOOST_FOREACH(matrix_t const & m, facSet.mkFactor() )
  //   cout << m << endl << sumMatrix(m) << endl << endl;

}
