#ifndef __Observations_h
#define __Observations_h

#include "phy/utils.h"
#include "phy/PhyDef.h"
#include "phy/SeqIO.h"
#include "boost/tuple/tuple.hpp"
#include "boost/foreach.hpp"
#include <boost/shared_ptr.hpp>
#include <boost/unordered_map.hpp> 
#include <string>
#include <vector>
#include <utility>
#include <algorithm>

using namespace std;

namespace phy {

  ////////////////////////////////////////////////////////////////
  // StateMaps: symbol_t -> state_t
  ////////////////////////////////////////////////////////////////


  /** Map input string (symbol_t) symbols to integer observation
      space. Degenerate observation symbols that map to several states
      are allowed. These symbols are mapped to metaStates with values
      greater than the basic states. Multiple symbols may map to the
      same set of states, however, they are assigned different
      metaStates internally.*/
  class StateMap {
  public:
    
    /** Constructor */
    StateMap(string const & symbols, string const & name = "") : state2Symbol_( stringToVectorOfStrings(symbols) ), name_(name) {init();}

    /** Constructor */
    StateMap(vector<symbol_t> const & symbols, string const & name = "") : state2Symbol_(symbols), name_(name) {init();}

    /** Constructor */
    StateMap(vector<symbol_t> const & symbols, boost::unordered_map<symbol_t, vector<symbol_t> > const & metaSymbolDegeneracyMap, string const & name = "") : state2Symbol_(symbols), degeneracyMap_(metaSymbolDegeneracyMap), name_(name) {init();}
 
    /** Constructor of n-long multiSymbols based on a basic stateMap. If staMap has a name, and no explicit name is given, the name of the constructed StateMap will be n-name.*/
    StateMap(StateMap const & staMap, unsigned n, string const & explicitName = "");
 
    /** Returns symbol corresponding to state i */
    symbol_t const & state2Symbol(state_t i) const {return state2Symbol_[i];}
    vector<symbol_t> const state2Symbol(vector<state_t> v) const;

    /** Returns state corresponding to symbol s. Aborts on nonexisting symbols. */
    state_t const & symbol2State(symbol_t const & s) const;
    vector<state_t> const symbol2State(vector<symbol_t> v) const;

    /** returns degeneracy vector for symbol s */
    vector<symbol_t> const degeneracyVector(symbol_t const & s) const;

    /** returns number of basic states */
    unsigned stateCount() const {return stateCount_;}

    /** returns number of meta states (includes basic states) */
    unsigned metaStateCount() const {return metaStateCount_;}

    /** returns length (in chars) of symbols */
    state_t symbolSize() const  {return symbolSize_;}

    /** Returns StateMap name. Name is empty ("") if not a canonical
	type. Useful in IO-functions. */
    string const & name() const {return name_;}

  protected:

    /** setup data structures */
    void init();

    vector<symbol_t> state2Symbol_;
    boost::unordered_map<symbol_t, state_t> symbol2State_;
    boost::unordered_map<symbol_t, vector<symbol_t> > degeneracyMap_;
    unsigned stateCount_;
    unsigned metaStateCount_;
    unsigned symbolSize_;
    string name_;
  };

  /** returns an n-state symbol with state 'state' based on stateMap. */
  symbol_t mkMultiStateSymbol(unsigned state, StateMap const & sm, unsigned n);

  /** returns a vector of all n-state symbols composed from single state symbols. Used to create multi nucleotide stateMaps. */
  vector<symbol_t> mkMultiStateSymbols(StateMap const & sm, unsigned n);

  /** Construct the degeneracy map for n-state symbols baed on the degeneracy map given in the input StateMap (staMap). */
  boost::unordered_map<symbol_t, vector<symbol_t> > mkMultiStateSymbolDegeneracyMap(boost::unordered_map<symbol_t, vector<symbol_t> > const & degMap, StateMap const & staMap, unsigned n);


  ////////////////////////////////////////////////////////////////
  // Nucleotide specific StateMaps
  ////////////////////////////////////////////////////////////////
   
  /** Return a symbol map for basic nucleotides */
  StateMap mkNucStateMap();

  /** Return a symbol map for basic nucleotides and IUPAC symbols. Can be used with DNA as well as RNA. */
  StateMap mkMetaNucStateMap();

  /** Returns a stateMap where each symbol consists of n nucleotides. */
  StateMap mkMultiNucStateMap(unsigned n);

  /** Returns a stateMap where each symbol consists of n nucleotides. Include degenerate symbols and should not be used for more than n=3.*/
  StateMap mkMultiMetaNucStateMap(unsigned n);


  ////////////////////////////////////////////////////////////////
  // StateMaskMaps: state_t -> stateMask_t
  ////////////////////////////////////////////////////////////////

  /* StateMaskMap allows conversion from (meta)states to stateMask_t,
     which are vectors of bools denoting if a state is observed or
     not. A stateMask_t is the natural input data structure for, e.g.,
     discrete factor graphs. **/
  class StateMaskMap {
  public:

    // to do: could allow dynamic calculation of stateMasks to save space
    StateMaskMap(StateMap const & staMap);

    /** Return the bit vector corresponding to state i */
    stateMask_t const & metaState2StateMask(state_t i) const {return metaState2StateMask_[i];}

  protected:
    
    vector<stateMask_t> metaState2StateMask_;
  };


  ////////////////////////////////////////////////////////////////
  // StateMaskMapSet: vector<symbol_t> -> stateMaskVec_t
  ////////////////////////////////////////////////////////////////

  typedef boost::shared_ptr<StateMaskMap> StateMaskMapPtr_t;
  typedef boost::shared_ptr<StateMap> StateMapPtr_t;

  /** Class that holds all the stateMasks for a given indexed set of
      random variables. Since the member functions return pointers to
      internally stored stateMasks, which are normally used in
      calculations on a factorGraph or similar, this datastructure
      must exist as long as calculations are performed or as long as
      the stateMasks are needed. */
  class StateMaskMapSet {
  public:

    /** Constructor to use when all random variables are over the same state space (i.e, all use the same StateMap). */
    StateMaskMapSet(StateMap const & staMap, unsigned n);

    /** Constructor to use when random variables are defined over different state spaces (i.e., they use different StateMaps). If StateMap is not defined for a random variable, a NULL pointer can be given.*/
    StateMaskMapSet(vector<StateMapPtr_t> const & stateMapVector);

    /** Convert a vector of symbols to a vector of observation
	masks. The indexing of symVec corresponds to the indexing of
	StateMaskMaps in StateMaskMapSet (which should correspond to the
	indexing of random variables in, e.g., a factor graph). The
	returned vector will have a stateMask pointer for each random
	variable. For unobserved random variables the version below
	can be used. */
    void symbols2StateMasks(stateMaskVec_t & obsMasVec, vector<symbol_t> const & symVec) const;
    stateMaskVec_t symbols2StateMasks(vector<symbol_t> const & symVec) const;

    /** Same as above but allows for unobserved variables. The randomVariableMap defines which random variable (and thus stateMask index) each index of symVec pertains to. obsMasVec[i] is set to null (missing data) if not pointed to by varMap. */
    stateMaskVec_t symbols2StateMasks(vector<symbol_t> const & symVec, vector<unsigned> const & varMap) const;
    void symbols2StateMasks(stateMaskVec_t & obsMasVec, vector<symbol_t> const & symVec, vector<unsigned> const & varMap) const;

    unsigned stateMapCount(void) const {return stateMapCount_;}
    unsigned symbolSize(unsigned idx) const {return stateMapVector_[idx]->symbolSize();}
    
  protected:
   
    unsigned stateMapCount_;
    vector<StateMapPtr_t> stateMapVector_;
    vector<StateMaskMapPtr_t> stateMaskMapVector_;
   };


  ////////////////////////////////////////////////////////////////
  // wrappers for making symbol_t and vector<symbol_t> from various
  // data types.
  // These are made inline for efficiency.
  ////////////////////////////////////////////////////////////////

  // precondition: the symbol (sym) is of correct size!
  // the symbol start position (symStartPos) is the first position of the symbol, I.e., largest meaningful pos is seqSize.
  inline void mkSymbol(symbol_t & sym, unsigned symSize, string const & seq, long seqSize, long symStartPos, char missingDataChar = '.')
  {
    long pos;
      for (unsigned i = 0; i < symSize; i++) {
	pos = symStartPos + i;
      if (pos < 0)
	sym[i] = missingDataChar;
      else if (pos >= seqSize)
	sym[i] = missingDataChar;
      else 
	sym[i] = seq[pos];
    }
  }


  inline symbol_t mkSymbol(unsigned symSize, string const & seq, long seqSize, long symStartPos, char missingDataChar = '.')
  {
    symbol_t sym(symSize, missingDataChar);
    mkSymbol(sym, symSize, seq, seqSize, symStartPos, missingDataChar);
    return sym;
  }
  
  
  inline void mkSymbolVector(vector<symbol_t> & symVec, vector<unsigned> const & symSizeVec, vector<string> const & strVec, unsigned seqSize, unsigned symStartPos, char missingData = '.')
  {
    for (unsigned i = 0; i < symVec.size(); i++)
      mkSymbol(symVec[i], symSizeVec[i], strVec[i], seqSize, symStartPos, missingData);
  }


  inline void mkSymbolVector(vector<symbol_t> & symVec, unsigned const commonSymSize, vector<string> const & strVec, unsigned seqSize, unsigned symStartPos, char missingData = '.')
  {
    for (unsigned i = 0; i < symVec.size(); i++)
      mkSymbol(symVec[i], commonSymSize, strVec[i], seqSize, symStartPos, missingData);
  }


  // A diSymbol is composed of left and a right part.
  // precondition: the symbol (sym) is of correct size!
  // the symbol start position (symStartPos) is the first position of the symbol, I.e., largest meaningful pos is seqSize.
  inline void mkDiSymbol(symbol_t & sym, unsigned const sizeLeft, unsigned const sizeRight, string const & seq, long const seqSize, long const leftStartPos, long const rightStartPos, char const missingDataChar = '.')
  {
    // left part
    long pos;
    for (unsigned i = 0; i < sizeLeft; i++) {
      pos = leftStartPos + i;
      if (pos < 0)
	sym[i] = missingDataChar;
      else if (pos >= seqSize)
	sym[i] = missingDataChar;
      else 
	sym[i] = seq[pos];
    }

    // right part
    for (unsigned i = 0; i < sizeRight; i++) {
      pos = rightStartPos + i;
      if (pos < 0)
	sym[sizeLeft + i] = missingDataChar;
      else if (pos >= seqSize)
	sym[sizeLeft + i] = missingDataChar;
      else 
	sym[sizeLeft + i] = seq[pos];
    }
  }


  inline symbol_t mkDiSymbol(unsigned const sizeLeft, unsigned const sizeRight, string const & seq, long const seqSize, long const leftStartPos, long const rightStartPos, char const missingDataChar = '.')
  {
    symbol_t sym(sizeLeft + sizeRight, missingDataChar);
    mkDiSymbol(sym, sizeLeft, sizeRight, seq, seqSize, leftStartPos, rightStartPos, missingDataChar);
    return sym;
  }


  // A diSymbol is composed of a left and a right part.
  inline void mkDiSymbolVector(vector<symbol_t> & symVec, unsigned const commonSizeLeft, unsigned const commonSizeRight, vector<string> const & strVec, unsigned const seqSize, unsigned const leftStartPos, unsigned const rightStartPos, char missingDataChar = '.')
  {
    for (unsigned i = 0; i < symVec.size(); i++)
      mkDiSymbol(symVec[i], commonSizeLeft, commonSizeRight, strVec[i], seqSize, leftStartPos, rightStartPos, missingDataChar);
  }




  ////////////////////////////////////////////////////////////////
  // wrappers for making stateMask2DVec from various data types.
  ////////////////////////////////////////////////////////////////

  /** varNames[i] gives the name of variabe with index i (may be the
      empty string). seqNames[i] gives the name of input sequence i
      (must match a unique varName). The returned varMap maps the
      observed sequences to variable indexes. */
  vector<unsigned> mkSeqToVarMap(vector<string> const & varNames, vector<string> const & seqNames);

  /** Initiates and returns the stateMask2DVec data structure. For convenience. */
  inline stateMask2DVec_t initStateMask2DVec(long seqLength, unsigned varCount) {return stateMask2DVec_t(seqLength, stateMaskVec_t(varCount) );}

  /** Convert input observation-symbol data to 2D vectors of state
      masks. These can be used as input for the Discrete Factor Graph
      framework. 'offSet' defines the offset from one symbol start
      position to the next in the sequences of input symbols. The
      character denoting missing symbols can be defined by the
      missingDataChar variable.

      preconditions: 
      1) All sequences within a data entry (strVec or SeqData) are assumed to be of equal length.
      2) When the state maske table is given as a reference, it is assumed have correct dimension: 
         1st. dim is the number of symbols in the input sequences (taking offSet into account).
	 2nd. dim is the number of variables as defined in the StateMaskMapSet.
  */
  void mkStateMask2DVec(vector<string> const & strVec, stateMask2DVec_t & stateMask2DVec, vector<unsigned> const & varMap, StateMaskMapSet const & stateMaskMapSet, unsigned offSet = 1, char missingDataChar = '.');
  stateMask2DVec_t mkStateMask2DVec(vector<string> const & strVec, vector<unsigned> const & seqToVarMap, unsigned varCount, StateMaskMapSet const & stateMaskMapSet, unsigned offSet = 1, char missingDataChar = '.');
  stateMask2DVec_t mkStateMask2DVec(SeqData const & seqData, vector<string> const & varNames, StateMaskMapSet const & stateMaskMapSet, unsigned offSet = 1, char missingDataChar = '.');
  stateMask2DVec_t mkStateMask2DVec(SeqData const & seqData, vector<unsigned> const & varMap, unsigned varCount, StateMaskMapSet const & stateMaskMapSet, unsigned offSet = 1, char missingDataChar = '.');

  // equivalent version for vectors of data sets
  vector<stateMask2DVec_t> const mkStateMask3DVec(vector<SeqData> const & seqDataVec, vector<string> const & varNames, StateMaskMapSet const & stateMaskMapSet, unsigned offSet = 1, char missingDataChar = '.');


  ////////////////////////////////////////////////////////////////
  // Helper functions
  ////////////////////////////////////////////////////////////////

  /** return the number of symbols in SeqData given a certain offset between each. */
  unsigned symbolCount(vector<string> const & strVec, unsigned offSet);




} // end namespace phy

#endif  //__Observations_h
