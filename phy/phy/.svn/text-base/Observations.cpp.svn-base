#include "phy/Observations.h"

namespace phy {

  StateMap::StateMap(StateMap const & staMap, unsigned n, string const & explicitName) : name_(explicitName)
  {
    state2Symbol_ = mkMultiStateSymbols(staMap, n);
    boost::unordered_map<symbol_t, vector<symbol_t> > degMap;
    for (unsigned i = staMap.stateCount(); i < staMap.metaStateCount(); i++) {
      symbol_t sym = staMap.state2Symbol(i);
      degMap[sym] = staMap.degeneracyVector(sym);
    }
    degeneracyMap_ = mkMultiStateSymbolDegeneracyMap(degMap, staMap, n);

    //mk name
    if (name_.size() == 0)
      if ( staMap.name().size() )
	name_ = toString(n) + "-" + staMap.name();

    init();
  }


  vector<symbol_t> const StateMap::state2Symbol(vector<state_t> v) const
  {
    vector<symbol_t> u( v.size() );
    for (unsigned i = 0; i < v.size(); i++) {
      u.push_back( state2Symbol(v[i]) );
    }
    return u;
  }


  // Returns state corresponding to symbol s. Aborts on nonexisting symbols.
  state_t const & StateMap::symbol2State(symbol_t const & s) const 
  {
    boost::unordered_map<symbol_t, state_t >::const_iterator it = symbol2State_.find(s);
    if ( it == symbol2State_.end() )
      errorAbort("StateMap::symbol2State: Symbol '" + s + "' not found in stateMap.");
    return it->second;
  }


  vector<state_t> const StateMap::symbol2State(vector<symbol_t> v) const
  {
    vector<state_t> u( v.size() );
    for (unsigned i = 0; i < v.size(); i++) {
      u.push_back( symbol2State(v[i]) );
    }
    return u;
  }


  //returns degeneracy vector for symbol s 
  vector<symbol_t> const StateMap::degeneracyVector(symbol_t const & s) const 
  {
    boost::unordered_map<symbol_t, vector<symbol_t> >::const_iterator it = degeneracyMap_.find(s);
    if ( it == degeneracyMap_.end() )
      errorAbort("StateMap::degeneracyVector: Symbol '" + s + "' not found in stateMap.");
    return it->second;
  }


  void StateMap::init()
  {
    stateCount_ = state2Symbol_.size();
    // add basic symbols to degeneracy map
    BOOST_FOREACH(symbol_t const & sym,  state2Symbol_)
      degeneracyMap_[sym] = vector<symbol_t>(1, sym);
    // add (only) metaSymbols to state2Symbols_
    symbol_t sym;
    vector<symbol_t> degSymVec;
    BOOST_FOREACH(boost::tie(sym, degSymVec), degeneracyMap_)
      if ( find(state2Symbol_.begin(), state2Symbol_.end(), sym) == state2Symbol_.end() ) // not found
	state2Symbol_.push_back(sym);
    metaStateCount_ = state2Symbol_.size();
    // symbol2State
    for (unsigned i = 0; i < metaStateCount_; i++)
      symbol2State_[ state2Symbol_[i] ] = i;
    // symbolSize
    symbolSize_= (stateCount_ > 0) ? state2Symbol_[0].size() : 0;
  }


  string mkMultiStateSymbol(unsigned state, StateMap const & sm, unsigned n)
  {
    symbol_t symbol;
    unsigned base = sm.stateCount();
    for (int j = n - 1; j >= 0; j--) {
      unsigned val = power(base, j);
      state_t subState = state / val;
      symbol += sm.state2Symbol(subState);
      state = state % val;
    }
    return symbol;
  }


  // returns a symbol string of all possible n-long symbols constructed from the StateMap symbols
  vector<symbol_t> mkMultiStateSymbols(StateMap const & sm, unsigned n)
  {
    unsigned stateCount = power(sm.stateCount(), n);
    vector<symbol_t> symbols;
    symbols.reserve(stateCount);
    for (unsigned i = 0; i < stateCount; i++)
      symbols.push_back( mkMultiStateSymbol(i, sm, n) );
    return symbols;
  }
    

  void addBasicSymbolsToDegeneracyMap(boost::unordered_map<symbol_t, vector<symbol_t> > & degMap, vector<symbol_t> const & symbols)
  {
    BOOST_FOREACH(symbol_t const & sym,  symbols)
      degMap[sym] = vector<symbol_t>(1, sym);
  }


  void addBasicSymbolsToDegeneracyMap(boost::unordered_map<symbol_t, vector<symbol_t> > & degMap, StateMap const & staMap)
  {
    vector<symbol_t> symbols;
    for (unsigned i = 0; i < staMap.stateCount(); i++) 
      symbols.push_back( staMap.state2Symbol(i) );
    addBasicSymbolsToDegeneracyMap(degMap, symbols);
  }


  // take a degeneracy map and the corresponding state map and output a degeneracy map for the corresponding multi state symbol set.
  boost::unordered_map<symbol_t, vector<symbol_t> > mkMultiStateSymbolDegeneracyMap(boost::unordered_map<symbol_t, vector<symbol_t> > const & degMap, StateMap const & staMap, unsigned n)
  {
    boost::unordered_map<symbol_t, vector<symbol_t> > extDegMap = degMap;
    addBasicSymbolsToDegeneracyMap(extDegMap, staMap);
    boost::unordered_map<symbol_t, vector<symbol_t> > mulDegMap = extDegMap;

    if (power(extDegMap.size(), n) > 100000) // 
      errorAbort("Silly number of degenerate symbols in multi-symbol degeneray map. Reimplement 'mkMultiStateDegeneracyMa' and related functions functions");

    // some loop internal variables
    boost::unordered_map<symbol_t, vector<symbol_t> > tmpMulDegMap;
    symbol_t preSym, appSym;
    vector<symbol_t> preDegSymVec, appDegSymVec;
    for (unsigned i = 1; i < n; i ++) {
      tmpMulDegMap.clear();
      BOOST_FOREACH(boost::tie(preSym, preDegSymVec), mulDegMap) {
	BOOST_FOREACH(boost::tie(appSym, appDegSymVec), extDegMap) {
	  symbol_t sym = preSym + appSym;
	  vector<symbol_t> degSymVec;
	  BOOST_FOREACH(symbol_t const & preDegSym, preDegSymVec) 
	    BOOST_FOREACH(symbol_t const & appDegSym, appDegSymVec) 
	    degSymVec.push_back(preDegSym + appDegSym);
	  tmpMulDegMap[sym] = degSymVec;
	}
      }
      mulDegMap = tmpMulDegMap;
    }
    return mulDegMap;
  }

  StateMap mkNucStateMap(void)
  {
    vector<symbol_t> symbols = stringToVectorOfStrings("ACGT");
    return StateMap(symbols, "nuc");
  }


  StateMap mkMetaNucStateMap(void)
  {
    vector<symbol_t> symbols = stringToVectorOfStrings("ACGT");
    boost::unordered_map<symbol_t, vector<symbol_t> > degMap;
    
    degMap["U"] = stringToVectorOfStrings("T"); 
    degMap["R"] = stringToVectorOfStrings("AG");
    degMap["Y"] = stringToVectorOfStrings("CT");
    degMap["K"] = stringToVectorOfStrings("GT");   
    degMap["M"] = stringToVectorOfStrings("CA");   
    degMap["S"] = stringToVectorOfStrings("CG");   
    degMap["W"] = stringToVectorOfStrings("AT");   
    degMap["B"] = stringToVectorOfStrings("CGT");  
    degMap["D"] = stringToVectorOfStrings("AGT");  
    degMap["H"] = stringToVectorOfStrings("ACT");  
    degMap["V"] = stringToVectorOfStrings("ACG");  
    degMap["N"] = stringToVectorOfStrings("ACGT");
    degMap["-"] = stringToVectorOfStrings("ACGT");
    degMap["."] = stringToVectorOfStrings("ACGT");

    return StateMap(symbols, degMap, "metaNuc");
  }


  // creates stateMap where each symbol consists of n nucleotides.
  StateMap mkMultiMetaNucStateMap(unsigned n)
  {
    StateMap metaNucMap = mkMetaNucStateMap();
    return StateMap(metaNucMap, n);
  }


  // creates stateMap where each symbol consists of n nucleotides.
  StateMap mkMultiNucStateMap(unsigned n)
  {
    StateMap nucMap = mkNucStateMap();
    return StateMap(nucMap, n);
  }


  StateMaskMap::StateMaskMap(StateMap const & staMap)
    : metaState2StateMask_( staMap.metaStateCount() , stateMask_t(staMap.stateCount(), false) )
  {
    unsigned metaCount = staMap.metaStateCount();
    
    for (unsigned i = 0; i < metaCount; i++) {
      symbol_t sym = staMap.state2Symbol(i);
      vector<symbol_t> const & v = staMap.degeneracyVector(sym);
      for (vector<symbol_t>::const_iterator it = v.begin(); it < v.end(); it++) {
	state_t j = staMap.symbol2State(*it);
	if (j >= staMap.stateCount()) 
	  errorAbort("StateMaskMap::StateMaskMap: Degenerate symbol '" + sym + "' is defined in terms of another meta-symbol '" + *it + "'.");
	metaState2StateMask_[i][j] = true;
      }
    }
  }


  StateMaskMapSet::StateMaskMapSet(StateMap const & staMap, unsigned n) : stateMapCount_(n), stateMapVector_(n), stateMaskMapVector_(n)
  {
    StateMapPtr_t staMapPtr(new StateMap(staMap));
    StateMaskMapPtr_t staMasPtr(new StateMaskMap(staMap));

    for (unsigned i = 0; i < n ;i++) {
      stateMapVector_[i] = staMapPtr;
      stateMaskMapVector_[i] = staMasPtr;
    }
  }


  StateMaskMapSet::StateMaskMapSet(vector<StateMapPtr_t> const & stateMapVector) : stateMapCount_( stateMapVector.size() ), stateMapVector_(stateMapVector), stateMaskMapVector_(stateMapVector.size() ) 
  {
    unsigned n = stateMapCount_;
    for (unsigned i = 0; i < n ;i++) 
      if (stateMapVector_[i] != NULL)
	stateMaskMapVector_[i] = StateMaskMapPtr_t(new StateMaskMap(*stateMapVector_[i]));
      else {
	stateMaskMapVector_[i] = StateMaskMapPtr_t();
	//errorAbort("from StateMaskMapSet::StateMaskMapSet: Null StateMapPtr for index " + toString(i) + ". This should not happen. ");
      }
  }

  void StateMaskMapSet::symbols2StateMasks(stateMaskVec_t & obsMasVec, vector<symbol_t> const & symVec) const
  {
    assert(symVec.size() == stateMapCount_);

    for (unsigned i = 0; i < stateMapCount_; i++) {
      unsigned state = stateMapVector_[i]->symbol2State( symVec[i] );
      obsMasVec[i] = & stateMaskMapVector_[i]->metaState2StateMask(state);
    }
  }


  stateMaskVec_t StateMaskMapSet::symbols2StateMasks(vector<symbol_t> const & symVec) const
  {
    stateMaskVec_t obsMasVec(stateMapCount_);
    symbols2StateMasks(obsMasVec, symVec);
    return obsMasVec;
  }


  void StateMaskMapSet::symbols2StateMasks(stateMaskVec_t & obsMasVec, vector<symbol_t> const & symVec, vector<unsigned> const & seqToVarMap) const
  {
    assert( symVec.size() == seqToVarMap.size() );
    assert( obsMasVec.size() == stateMapCount_ );

    for (unsigned i = 0; i < stateMapCount_; i++)
      obsMasVec[i] = NULL;
    for (unsigned i = 0; i < symVec.size(); i++) {
      unsigned ranVarIdx = seqToVarMap[i];
      state_t state = stateMapVector_[ranVarIdx]->symbol2State( symVec[i] );
      obsMasVec[ ranVarIdx ] = & stateMaskMapVector_[ranVarIdx]->metaState2StateMask(state);
    }
  }


  stateMaskVec_t StateMaskMapSet::symbols2StateMasks(vector<symbol_t> const & symVec, vector<unsigned> const & seqToVarMap) const
  {
    stateMaskVec_t obsMasVec(stateMapCount_);
    symbols2StateMasks(obsMasVec, symVec, seqToVarMap);
    return obsMasVec;
  }


  vector<unsigned> mkSeqToVarMap(vector<string> const & varNames, vector<string> const & seqNames)
  {
    return mkSubsetMap(varNames, seqNames);
  }

  // preconditions: 
  // strVec contains all input sequences, which are assumed of equal length
  // stateMask2DVec the same length as the input sequences. 
  void mkStateMask2DVec(vector<string> const & strVec, stateMask2DVec_t & stateMask2DVec, vector<unsigned> const & seqToVarMap, StateMaskMapSet const & stateMaskMapSet, unsigned offSet, char missingDataChar)
  {
    unsigned seqSize = strVec[0].size();
    unsigned symCount = symbolCount(strVec, offSet);
    assert( symCount == stateMask2DVec.size() );
    unsigned symVecSize = strVec.size();

    // get symbol sizes
    vector<unsigned> symSizeVec(symVecSize);
    for (unsigned i = 0; i < symVecSize; i++)
      symSizeVec[i] = stateMaskMapSet.symbolSize( seqToVarMap[i] );
    
    // setup symbol vector
    vector<symbol_t> symVec(symVecSize);
    for (unsigned i = 0; i < symVecSize; i++)
      symVec[i].resize( symSizeVec[i] );

    // fill in stateMask table
    for (unsigned i = 0; i < symCount; i++) {
      mkSymbolVector(symVec, symSizeVec, strVec, seqSize, i * offSet, missingDataChar);
      stateMaskMapSet.symbols2StateMasks(stateMask2DVec[i], symVec, seqToVarMap);
    }      
  }


  stateMask2DVec_t mkStateMask2DVec(vector<string> const & strVec, vector<unsigned> const & seqToVarMap, unsigned varCount, StateMaskMapSet const & stateMaskMapSet, unsigned offSet, char missingDataChar)
  {
    assert(strVec.size() > 0);
    stateMask2DVec_t stateMask2DVec = initStateMask2DVec(symbolCount(strVec, offSet), varCount);
    mkStateMask2DVec(strVec, stateMask2DVec, seqToVarMap, stateMaskMapSet, offSet, missingDataChar);
    return stateMask2DVec;
  }


  stateMask2DVec_t mkStateMask2DVec(SeqData const & seqData, vector<string> const & varNames, StateMaskMapSet const & stateMaskMapSet, unsigned offSet, char missingDataChar)
  {
    vector<unsigned> seqToVarMap = mkSeqToVarMap(varNames, seqData.seqNames);
    unsigned varCount = varNames.size();
    return mkStateMask2DVec(seqData, seqToVarMap, varCount, stateMaskMapSet, offSet, missingDataChar);
  }


  stateMask2DVec_t mkStateMask2DVec(SeqData const & seqData, vector<unsigned> const & seqToVarMap, unsigned varCount, StateMaskMapSet const & stateMaskMapSet, unsigned offSet, char missingDataChar)
  {
    return mkStateMask2DVec(seqData.sequences, seqToVarMap, varCount, stateMaskMapSet, offSet, missingDataChar);
  }


  vector<stateMask2DVec_t> const mkStateMask3DVec(vector<SeqData> const & seqDataVec, vector<string> const & varNames, StateMaskMapSet const & stateMaskMapSet, unsigned offSet, char missingDataChar)
  {
    vector<stateMask2DVec_t> resultVec;
    for (unsigned i = 0; i < seqDataVec.size(); i++)
      resultVec.push_back( mkStateMask2DVec(seqDataVec[i], varNames, stateMaskMapSet, offSet, missingDataChar) );
    return resultVec;
  }


  unsigned symbolCount(vector<string> const & strVec, unsigned offSet)
  {
    assert(offSet > 0);
    unsigned seqSize = (strVec.size() > 0) ? strVec[0].size() : 0;
    unsigned symCount = (seqSize + (offSet - 1) ) / offSet;  // number of symbols in input sequences. The result should be ceil for integer division.
    return symCount;
  }



  
} // end namespace phy
